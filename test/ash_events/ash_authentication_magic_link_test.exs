# SPDX-FileCopyrightText: 2023 ash_events contributors <https://github.com/ash-project/ash_events/graphs.contributors>
#
# SPDX-License-Identifier: MIT

defmodule AshEvents.AshAuthenticationMagicLinkTest do
  @moduledoc """
  Comprehensive tests for AshEvents compatibility with AshAuthentication magic link strategies.
  Tests magic link request and sign-in flows while verifying events are created correctly.
  """

  use AshEvents.RepoCase, async: false

  alias AshEvents.Accounts.User
  alias AshEvents.EventLogs
  alias AshEvents.EventLogs.EventLog
  alias AshEvents.EventLogs.SystemActor

  require Ash.Query

  # Helper function to clear all data before each test
  setup do
    # Clear all users and events using system actor to bypass policies
    system_actor = %SystemActor{name: "test_cleanup"}
    User |> Ash.read!(actor: system_actor) |> Enum.each(&Ash.destroy!(&1, actor: system_actor))
    EventLog |> Ash.read!() |> Enum.each(&Ash.destroy!/1)
    :ok
  end

  # Helper function to generate a proper magic link token for testing
  # This uses AshAuthentication's actual magic link token generation
  defp generate_magic_link_token_for_email(email) do
    # Get the magic link strategy
    strategy = AshAuthentication.Info.strategy!(User, :magic_link)

    # Create a user struct for token generation
    user_struct = %User{
      id: Ash.UUID.generate(),
      email: Ash.CiString.new(email)
    }

    # Use AshAuthentication's proper magic link token generation
    {:ok, token} = AshAuthentication.Strategy.MagicLink.request_token_for(strategy, user_struct)
    token
  end

  describe "magic link request" do
    test "requesting magic link for new email succeeds" do
      email = "newuser@example.com"

      # Request magic link
      {:ok, _result} =
        User
        |> Ash.Query.for_read(
          :request_magic_link,
          %{email: email},
          context: %{private: %{ash_authentication?: true}}
        )
        |> Ash.read()

      # The request should succeed
      # In a real app, this would send an email with a magic link
      # Our mock sender just logs the token
    end

    test "requesting magic link for existing user email succeeds" do
      # First create a user via password registration
      email = "existing@example.com"
      password = "password123"

      {:ok, _existing_user} =
        User
        |> Ash.Changeset.for_action(
          :register_with_password,
          %{
            email: email,
            password: password,
            password_confirmation: password
          }
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      # Request magic link for existing user
      {:ok, _result} =
        User
        |> Ash.Query.for_read(
          :request_magic_link,
          %{email: email},
          context: %{private: %{ash_authentication?: true}}
        )
        |> Ash.read()

      # The request should succeed
    end

    test "magic link request with invalid email format succeeds silently" do
      # Request magic link with invalid email
      # AshAuthentication may succeed silently for security reasons
      {:ok, _result} =
        User
        |> Ash.Query.for_read(
          :request_magic_link,
          %{email: "not-an-email"},
          context: %{private: %{ash_authentication?: true}}
        )
        |> Ash.read()

      # The request succeeds silently (security best practice)
      # In a real app, this would not send an email but appears to succeed
    end
  end

  describe "magic link sign in - new user registration" do
    test "new user can register via magic link and events are created" do
      email = "magicnew@example.com"

      # Mock a magic link token (in real usage, this comes from the email link)
      # For testing, we'll use the sign_in_with_magic_link action directly
      # since we can't actually receive emails in tests

      # Note: The magic link flow typically involves:
      # 1. User requests magic link via email
      # 2. User clicks link in email which contains a token
      # 3. App validates token and signs user in (creating account if needed)

      # For testing purposes, we'll simulate step 3 with a valid token
      # In a real implementation, the token would be generated by request_magic_link
      token = generate_magic_link_token_for_email(email)

      # Simulate magic link sign in for new user
      {:ok, user} =
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: token}
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      # Verify user was created
      assert to_string(user.email) == email
      assert user.id != nil

      # Verify authentication token was generated
      assert user.__metadata__.token != nil

      # Verify events were created
      events =
        EventLog
        |> Ash.Query.filter(resource == ^User and record_id == ^user.id)
        |> Ash.Query.sort({:id, :asc})
        |> Ash.read!()

      assert [_ | _] = events

      # Find the magic link sign-in event
      magic_link_event = Enum.find(events, &(&1.action == :sign_in_with_magic_link))
      assert magic_link_event != nil
      assert magic_link_event.resource == User
      assert magic_link_event.action == :sign_in_with_magic_link

      # Verify event data contains user information (but not sensitive data)
      assert magic_link_event.changed_attributes["email"] == email
      # Should not store sensitive token
      assert magic_link_event.data["token"] != nil

      # Verify event metadata
      # No user actor for self-registration
      assert magic_link_event.user_id == nil
      # No system actor
      assert magic_link_event.system_actor == nil
    end
  end

  describe "magic link sign in - existing user" do
    setup do
      # Create an existing user via password registration
      email = "existing@example.com"
      password = "existing_password123"

      {:ok, user} =
        User
        |> Ash.Changeset.for_action(
          :register_with_password,
          %{
            email: email,
            password: password,
            password_confirmation: password
          }
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      {:ok, user: user, email: email}
    end

    test "existing user can sign in via magic link", %{user: existing_user, email: email} do
      # Generate mock magic link token for existing user
      token = generate_magic_link_token_for_email(email)

      {:ok, existing_user} =
        existing_user
        |> Ash.Changeset.for_action(
          :confirm,
          %{
            email: email,
            confirm: existing_user.__metadata__.confirmation_token
          }
        )
        |> Ash.update(context: %{private: %{ash_authentication?: true}})

      # Sign in via magic link (should update existing user, not create new one)
      {:ok, signed_in_user} =
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: token}
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      # Verify it's the same user
      assert signed_in_user.id == existing_user.id
      assert to_string(signed_in_user.email) == email

      # Verify authentication token was generated
      assert signed_in_user.__metadata__.token != nil

      # Verify total user count is still 1 (upsert behavior)
      system_actor = %SystemActor{name: "verify_count"}
      all_users = User |> Ash.read!(actor: system_actor)
      assert length(all_users) == 1
    end
  end

  describe "magic link authentication with invalid tokens" do
    test "sign in with invalid token format fails" do
      # Attempt sign in with malformed token
      assert_raise Ash.Error.Forbidden, fn ->
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: "invalid_token_format"}
        )
        |> Ash.create!(context: %{private: %{ash_authentication?: true}})
      end

      # Verify no user was created
      system_actor = %SystemActor{name: "verify_empty"}
      users = User |> Ash.read!(actor: system_actor)
      assert Enum.empty?(users)
    end

    test "sign in with expired token fails" do
      email = "expired@example.com"

      token_secret = Application.get_env(:ash_events, :token_signing_secret)
      # Generate an expired token
      expired_token =
        Phoenix.Token.sign(token_secret, "magic_link", %{
          email: email,
          # Expired 1 hour ago
          exp: System.system_time(:second) - 3600
        })

      # Attempt sign in with expired token
      assert_raise Ash.Error.Forbidden, fn ->
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: expired_token}
        )
        |> Ash.create!(context: %{private: %{ash_authentication?: true}})
      end

      # Verify no user was created
      system_actor = %SystemActor{name: "verify_empty"}
      users = User |> Ash.read!(actor: system_actor)
      assert Enum.empty?(users)
    end
  end

  describe "event replay with magic link authentication" do
    test "magic link authentication events can be replayed correctly" do
      email = "replay@example.com"

      # Register user via magic link
      token = generate_magic_link_token_for_email(email)

      {:ok, original_user} =
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: token}
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      # Store original user data
      original_user_id = original_user.id
      original_email = original_user.email

      :ok = EventLogs.replay_events!()

      # Verify user was recreated with correct state
      system_actor = %SystemActor{name: "replay_verify"}
      replayed_users = User |> Ash.read!(actor: system_actor)
      assert length(replayed_users) == 1

      replayed_user = hd(replayed_users)
      assert replayed_user.email == original_email
      assert replayed_user.id == original_user_id

      # Note: After replay, the user should still be able to authenticate
      # This verifies that the magic link registration was properly replayed
    end

    test "magic link events for existing users replay correctly" do
      email = "existing_replay@example.com"
      password = "password123"

      # First create user via password
      {:ok, password_user} =
        User
        |> Ash.Changeset.for_action(
          :register_with_password,
          %{
            email: email,
            password: password,
            password_confirmation: password
          }
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      {:ok, password_user} =
        password_user
        |> Ash.Changeset.for_action(
          :confirm,
          %{
            email: email,
            confirm: password_user.__metadata__.confirmation_token
          }
        )
        |> Ash.update(context: %{private: %{ash_authentication?: true}})

      # Then sign in via magic link (should update, not create new user)
      token = generate_magic_link_token_for_email(email)

      {:ok, magic_link_user} =
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: token}
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      # Should be same user due to upsert
      assert magic_link_user.id == password_user.id

      # Replay events
      :ok = EventLogs.replay_events!()

      # Verify user was recreated correctly
      system_actor = %SystemActor{name: "replay_verify"}
      replayed_users = User |> Ash.read!(actor: system_actor)
      assert length(replayed_users) == 1

      replayed_user = hd(replayed_users)
      assert replayed_user.id == password_user.id
      assert to_string(replayed_user.email) == email
      assert replayed_user.confirmed_at == password_user.confirmed_at

      # User should still be able to sign in with password after replay
      {:ok, signed_in_user} =
        User
        |> Ash.Query.for_read(
          :sign_in_with_password,
          %{
            email: email,
            password: password
          }
        )
        |> Ash.read_one(context: %{private: %{ash_authentication?: true}})

      assert signed_in_user != nil
      assert signed_in_user.id == replayed_user.id
    end
  end

  describe "magic link authentication with actor attribution" do
    test "magic link operations with system actors are properly attributed in events" do
      email = "system@example.com"
      actor = %SystemActor{name: "magic_link_system"}

      # Request magic link with system actor
      {:ok, _result} =
        User
        |> Ash.Query.for_read(
          :request_magic_link,
          %{email: email},
          actor: actor
        )
        |> Ash.read()

      # Register via magic link with system actor
      token = generate_magic_link_token_for_email(email)

      {:ok, user} =
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: token},
          actor: actor
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      # Verify system actor attribution in events
      events =
        EventLog
        |> Ash.Query.filter(resource == ^User and record_id == ^user.id)
        |> Ash.read!()

      assert [_ | _] = events

      magic_link_event = Enum.find(events, &(&1.action == :sign_in_with_magic_link))
      assert magic_link_event != nil
      assert magic_link_event.system_actor == "magic_link_system"
      # System actor, not user actor
      assert magic_link_event.user_id == nil
    end
  end

  describe "integration with password authentication" do
    test "user can switch between password and magic link authentication" do
      email = "hybrid@example.com"
      password = "hybrid_password123"

      # Start with password registration
      {:ok, password_user} =
        User
        |> Ash.Changeset.for_action(
          :register_with_password,
          %{
            email: email,
            password: password,
            password_confirmation: password
          }
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      {:ok, password_user} =
        password_user
        |> Ash.Changeset.for_action(
          :confirm,
          %{
            email: email,
            confirm: password_user.__metadata__.confirmation_token
          }
        )
        |> Ash.update(context: %{private: %{ash_authentication?: true}})

      # User should be able to sign in with password
      {:ok, signed_in_password} =
        User
        |> Ash.Query.for_read(
          :sign_in_with_password,
          %{
            email: email,
            password: password
          }
        )
        |> Ash.read_one(context: %{private: %{ash_authentication?: true}})

      assert signed_in_password != nil
      assert signed_in_password.id == password_user.id

      # User should also be able to sign in with magic link
      token = generate_magic_link_token_for_email(email)

      {:ok, magic_link_user} =
        User
        |> Ash.Changeset.for_action(
          :sign_in_with_magic_link,
          %{token: token}
        )
        |> Ash.create(context: %{private: %{ash_authentication?: true}})

      # Should be the same user (upsert behavior)
      assert magic_link_user.id == password_user.id

      # Total users should still be 1
      system_actor = %SystemActor{name: "verify_count"}
      all_users = User |> Ash.read!(actor: system_actor)
      assert length(all_users) == 1

      # Both authentication methods should generate appropriate events
      all_events =
        EventLog
        |> Ash.Query.filter(resource == ^User and record_id == ^password_user.id)
        |> Ash.Query.sort({:id, :asc})
        |> Ash.read!()

      # Should have events for both registration types
      password_events = Enum.filter(all_events, &(&1.action == :register_with_password))
      magic_link_events = Enum.filter(all_events, &(&1.action == :sign_in_with_magic_link))

      assert [_ | _] = password_events
      assert [_ | _] = magic_link_events
    end
  end
end
